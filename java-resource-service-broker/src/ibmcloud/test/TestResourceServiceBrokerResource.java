/**
 * Sample IBM Cloud Java jax-rs Resource Broker Service Broker.
 */
package ibmcloud.test;

import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Enumeration;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.UUID;
import java.util.logging.Logger;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;
import javax.xml.bind.DatatypeConverter;

import org.apache.wink.client.ClientConfig;
import org.apache.wink.client.ClientResponse;
import org.apache.wink.client.Resource;
import org.apache.wink.client.RestClient;
import org.apache.wink.json4j.JSONArray;
import org.apache.wink.json4j.JSONException;
import org.apache.wink.json4j.JSONObject;

@Path("/")
public final class TestResourceServiceBrokerResource
{
    // TODO - This service name must be unique within an IBM Cloud environment's set of service offerings
    private static final String SERVICE_NAME = "testjavaresourceservicebrokername";

    // TODO - Change your basic authentication credentials
    private static final String SERVICE_BROKER_USER     = "TestServiceBrokerUser";
    private static final String SERVICE_BROKER_PASSWORD = "TestServiceBrokerPassword";

    // TODO - Change your client secret
    private static final String CLIENT_ID     = SERVICE_NAME;
    private static final String CLIENT_SECRET = "";

    // TODO - Change your API key value
    private static final String API_KEY = "";

    // TODO - Whether asynchronous operations are supported or not
    private static final boolean ASYNC_SUPPORTED = false;

    // TODO - If asynchronous operation is required due to time requirements
    private static final boolean ASYNC_REQUIRED = false;

    // TODO - Whether service keys are supported or not
    private static final boolean SERVICE_KEYS_SUPPORTED = true;

    private static final String IAM_ENDPOINT          = "https://iam.cloud.ibm.com";
    private static final String IAM_IDENTITY_ENDPOINT = IAM_ENDPOINT + "/identity/.well-known/openid-configuration";

    private static final Logger LOGGER = Logger.getLogger(TestResourceServiceBrokerResource.class.getName());

    /**
     * GET for testing. Not invoked by IBM Cloud.
     */
    @SuppressWarnings("static-method")
    @GET
    @Produces(MediaType.TEXT_HTML)
    public String get(@Context final HttpServletRequest httpServletRequest)
    {
        LOGGER.info("GET / request headers: " + headersString(httpServletRequest));

        return "This is a test";
    }

    @SuppressWarnings("static-method")
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("v2/catalog")
    public Response catalog(@Context final HttpServletRequest httpServletRequest)
           throws JSONException,
                  URISyntaxException
    {
        LOGGER.info("GET /v2/catalog request headers: " + headersString(httpServletRequest));

        validateAuthorization(httpServletRequest);

        final JSONObject originatingIdentity = getOriginatingIdentity(httpServletRequest);
        LOGGER.info("GET /v2/catalog originating identity: " + originatingIdentity.toString());

        // Service plan bullets
        final String[] resultPlanBullets = new String[2];
        resultPlanBullets[0] = "Test bullet 1";
        resultPlanBullets[1] = "Test bullet 2";

        // Service plan metadata
        final JSONObject resultPlanMetadata = new JSONObject();
        resultPlanMetadata.put("bullets",     resultPlanBullets);
        resultPlanMetadata.put("displayName", "Lite");

        // Service plan
        final JSONObject resultPlan = new JSONObject();
        resultPlan.put("bindable",    true);
        resultPlan.put("description", "Test Java Resource Service Broker Plan Description");
        resultPlan.put("free",        true);
        // TODO - GUID generated by http://www.guidgenerator.com
        // TODO - This service plan id must be unique within an IBM Cloud environment's set of service plans
        resultPlan.put("id",          "e62e2c19-0c3b-41e3-b8b3-c71762ecd489");
        resultPlan.put("metadata",    resultPlanMetadata);
        // TODO - This service plan name must be unique within the containing service definition
        resultPlan.put("name",        "lite");

        // Service plans
        final JSONArray resultPlans = new JSONArray();
        resultPlans.add(resultPlan);

        // Base URI
        final URI baseMetadataURI = new URI("https",
                                            httpServletRequest.getServerName(),
                                            httpServletRequest.getContextPath(),
                                            null);

        // Service metadata
        final JSONObject resultServiceMetadata = new JSONObject();
        resultServiceMetadata.put("displayName",         "Test Java Resource Service Broker Display Name");
        resultServiceMetadata.put("documentationUrl",    baseMetadataURI + "/public/documentation.html");
        resultServiceMetadata.put("imageUrl",            baseMetadataURI + "/public/services.svg"); // Copied from https://github.com/carbon-design-system/carbon-icons/blob/master/src/svg/services.svg
        resultServiceMetadata.put("instructionsUrl",     baseMetadataURI + "/public/instructions.html");
        resultServiceMetadata.put("longDescription",     "Test Java Resource Service Broker Long Description");
        resultServiceMetadata.put("providerDisplayName", "Company Name");
        resultServiceMetadata.put("supportUrl",          baseMetadataURI + "/public/support.html");
        resultServiceMetadata.put("termsUrl",            baseMetadataURI + "/public/terms.html");

        // Service tags
        final String[] resultTags = new String[3];
        resultTags[0] = "lite";
        resultTags[1] = "tag1a";
        resultTags[2] = "tag1b";

        // Service
        final JSONObject resultService = new JSONObject();
        resultService.put("bindable",        true);
        resultService.put("description",     "Test Java Resource Service Broker Description");
        // TODO - GUID generated by http://www.guidgenerator.com
        // TODO - This service id must be unique within an IBM Cloud environment's set of service offerings
        resultService.put("id",              "cb55391b-3416-4943-a6a6-a541778c1924");
        resultService.put("metadata",        resultServiceMetadata);
        // TODO - This service name must be unique within an IBM Cloud environment's set of service offerings
        resultService.put("name",            SERVICE_NAME);
        // TODO - Ensure this value is accurate for your service. Requires PATCH of v2/service_instances/{instanceId} below if true
        resultService.put("plan_updateable", true);
        resultService.put("plans",           resultPlans);
        resultService.put("tags",            resultTags);

        // Services
        final JSONArray resultServices = new JSONArray();
        resultServices.add(resultService);

        // Result
        final JSONObject result = new JSONObject();
        result.put("services", resultServices);

        LOGGER.info("GET /v2/catalog result: " + result);

        return Response.ok(result).build();
    }

    @SuppressWarnings("static-method")
    @PUT
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Path("v2/service_instances/{instanceId}")
    public Response provision(@Context                          final HttpServletRequest httpServletRequest,
                              @PathParam("instanceId")          final String             instanceId,
                              @QueryParam("accepts_incomplete") final boolean            acceptsIncomplete,
                                                                final JSONObject         jsonObject)
           throws JSONException,
                  UnsupportedEncodingException,
                  URISyntaxException
    {
        LOGGER.info("PUT /v2/service_instances/" + instanceId + "?accepts_incomplete=" + acceptsIncomplete + " request headers: " + headersString(httpServletRequest));

        validateAuthorization(httpServletRequest);

        final JSONObject originatingIdentity = getOriginatingIdentity(httpServletRequest);
        LOGGER.info("PUT /v2/service_instances/" + instanceId + "?accepts_incomplete=" + acceptsIncomplete + " originating identity: " + originatingIdentity.toString());

        LOGGER.info("PUT /v2/service_instances/" + instanceId + "?accepts_incomplete=" + acceptsIncomplete + " body: " + jsonObject);

        final JSONObject context    = getInputJSONObject(jsonObject, "context", true);
        final JSONObject parameters = getInputJSONObject(jsonObject, "parameters", false); // Optional
        final String planId         = getInputString(jsonObject, "plan_id", true);
        final String serviceId      = getInputString(jsonObject, "service_id", true);

        final String platform = getInputString(context, "platform", true);

        // IBM Cloud context fields
        String accountId        = null;
        String crn              = null;
        String resourceGroupCRN = null;
        String targetCRN        = null;

        if ("ibmcloud".equals(platform))
        {
            // Retrieve the various IBM Cloud-specific context fields
            accountId        = getInputString(context, "account_id", true);
            crn              = getInputString(context, "crn", true);
            resourceGroupCRN = getInputString(context, "resource_group_crn", true);
            targetCRN        = getInputString(context, "target_crn", true);
        }

        final JSONObject result = new JSONObject();

        final int status;

        // If the service only supports asynchronous operations and acceptsIncomplete is not true
        if (ASYNC_SUPPORTED && ASYNC_REQUIRED && !acceptsIncomplete)
        {
            result.put("error",       "AsyncRequired");
            result.put("description", "This service plan requires client support for asynchronous service operations."); // TODO - This optional field is a user-facing message

            status = 422;
        }
        else
        {
            final URI dashboardBaseURI = new URI("https",
                                                 httpServletRequest.getServerName(),
                                                 httpServletRequest.getContextPath() + "/dashboard/",
                                                 null);

            result.put("dashboard_url", dashboardBaseURI + URLEncoder.encode(instanceId, "UTF-8"));

            // TODO - If the service instance is requested as asynchronous (and time is needed to provision beyond the standard timeout)
            if (ASYNC_SUPPORTED && acceptsIncomplete)
            {
                // TODO - Kick off your asynchronous work here

                result.put("description", "This service instance is being created asynchronously for you."); // TODO - This optional field is a user-facing message.
                result.put("operation",   "Test provision"); // Passed in on subsequent fetch requests

                status = 202;
            }
            else
            {
                // TODO - Do your actual synchronous work here

                // Created response, but does not expect URL
                status = 201;
            }
        }

        LOGGER.info("PUT /v2/service_instances/" + instanceId + "?accepts_incomplete=" + acceptsIncomplete + " status: " + status + ", result: " + result);

        return Response.status(status).entity(result).build(); // Return 409 if already provisioned at this url
    }

    @SuppressWarnings("static-method")
    @PUT
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Path("v2/service_instances/{instanceId}/service_bindings/{bindingId}")
    public Response bind(@Context                 final HttpServletRequest httpServletRequest,
                         @PathParam("instanceId") final String             instanceId,
                         @PathParam("bindingId")  final String             bindingId,
                                                  final JSONObject         jsonObject)
           throws JSONException
    {
        LOGGER.info("PUT /v2/service_instances/" + instanceId + "/service_bindings/" + bindingId + " request headers: " + headersString(httpServletRequest));

        validateAuthorization(httpServletRequest);

        final JSONObject originatingIdentity = getOriginatingIdentity(httpServletRequest);
        LOGGER.info("PUT /v2/servive_instances/" + instanceId + "/service_bindings/" + bindingId + " originating identity: " + originatingIdentity.toString());

        LOGGER.info("PUT /v2/service_instances/" + instanceId + "/service_bindings/" + bindingId + " body: " + jsonObject);

        final JSONObject bindResource = getInputJSONObject(jsonObject, "bind_resource", false); // Not required if for service_key
        final JSONObject context      = getInputJSONObject(jsonObject, "context", false); // Not available until OSB 2.13
        final JSONObject parameters   = getInputJSONObject(jsonObject, "parameters", false); // Optional
        final String planId           = getInputString(jsonObject, "plan_id", true);
        final String serviceId        = getInputString(jsonObject, "service_id", true);
        String appGuid                = null;

        if (bindResource != null)
        {
            appGuid = getInputString(bindResource, "app_guid", false); // Only required if binding app to service instance
        }

        if (context != null)
        {
            final String platform = getInputString(context, "platform", true);

            if ("ibmcloud".equals(platform))
            {
                // Retrieve the various IBM Cloud-specific context fields here
            }
        }

        final JSONObject result = new JSONObject();

        final int status;

        // If appGUID not provided and service keys are not supported
        if ((appGuid == null) && !SERVICE_KEYS_SUPPORTED)
        {
            result.put("error",       "RequiresApp");
            result.put("description", "This service supports generation of credentials through binding an application only."); // TODO - This optional field is a user-facing message

            status = 422;
        }
        else
        {
            // TODO - Do your actual work here

            final UUID generatedUserid   = UUID.randomUUID();
            final UUID generatedPassword = UUID.randomUUID();

            final JSONObject resultCredentials = new JSONObject();
            resultCredentials.put("userid",   generatedUserid.toString());
            resultCredentials.put("password", generatedPassword.toString());
            result.put("credentials", resultCredentials);

            // Created response, but does not expect URL
            status = 201;
        }

        LOGGER.info("PUT /v2/service_instances/" + instanceId + "/service_bindings/" + bindingId + " status: " + status + ", result: " + result);

        return Response.status(status).entity(result).build(); // Return 409 if already provisioned at this url
    }

    @SuppressWarnings("static-method")
    @DELETE
    @Produces(MediaType.APPLICATION_JSON)
    @Path("v2/service_instances/{instanceId}/service_bindings/{bindingId}")
    public Response unbind(@Context                  final HttpServletRequest httpServletRequest,
                           @PathParam("instanceId")  final String             instanceId,
                           @PathParam("bindingId")   final String             bindingId,
                           @QueryParam("plan_id")    final String             planId,
                           @QueryParam("service_id") final String             serviceId)
           throws JSONException
    {
        LOGGER.info("DELETE /v2/service_instances/" + instanceId + "/service_bindings/" + bindingId + "?plan_id=" + planId + "&service_id=" + serviceId + " request headers: " + headersString(httpServletRequest));

        validateAuthorization(httpServletRequest);

        final JSONObject originatingIdentity = getOriginatingIdentity(httpServletRequest);
        LOGGER.info("DELETE /v2/service_instances/" + instanceId + "/service_bindings/" + bindingId + "?plan_id=" + planId + "&service_id=" + serviceId + " originating identity: " + originatingIdentity.toString());

        // TODO - Do your actual work here

        final JSONObject result = new JSONObject();

        LOGGER.info("DELETE /v2/service_instances/" + instanceId + "/service_bindings/" + bindingId + "?plan_id=" + planId + "&service_id=" + serviceId + " result: " + result);

        return Response.ok(result).build(); // Return 410 with body of {} if previously deleted
    }

    @SuppressWarnings("static-method")
    @DELETE
    @Produces(MediaType.APPLICATION_JSON)
    @Path("v2/service_instances/{instanceId}")
    public Response unprovision(@Context                          final HttpServletRequest httpServletRequest,
                                @PathParam("instanceId")          final String             instanceId,
                                @QueryParam("accepts_incomplete") final boolean            acceptsIncomplete,
                                @QueryParam("plan_id")            final String             planId,
                                @QueryParam("service_id")         final String             serviceId)
           throws JSONException
    {
        LOGGER.info("DELETE /v2/service_instances/" + instanceId + "?accepts_incomplete=" + acceptsIncomplete + "&plan_id=" + planId + "&service_id=" + serviceId + " request headers: " + headersString(httpServletRequest));

        validateAuthorization(httpServletRequest);

        final JSONObject originatingIdentity = getOriginatingIdentity(httpServletRequest);
        LOGGER.info("DELETE /v2/service_instances/" + instanceId + "?accepts_incomplete=" + acceptsIncomplete + "&plan_id=" + planId + "&service_id=" + serviceId + " originating identity: " + originatingIdentity.toString());

        final JSONObject result = new JSONObject();

        final int status;

        // If the service only supports asynchronous operations and acceptsIncomplete is not true
        if (ASYNC_SUPPORTED && ASYNC_REQUIRED && !acceptsIncomplete)
        {
            result.put("error",       "AsyncRequired");
            result.put("description", "This service plan requires client support for asynchronous service operations."); // TODO - This optional field is a user-facing message

            status = 422;
        }
        // TODO - Else if the service instance is requested as asynchronous (and time is needed to deprovision beyond the standard timeout)
        else if (ASYNC_SUPPORTED && acceptsIncomplete)
        {
            // TODO - Kick off your asynchronous work here

            result.put("description", "This service instance is being deleted asynchronously for you."); // TODO - This optional field is a user-facing message.
            result.put("operation",   "Test deprovision"); // Passed in on subsequent fetch requests

            status = 202;
        }
        else
        {
            // TODO - Do your actual synchronous work here

            status = 200;
        }

        LOGGER.info("DELETE /v2/service_instances/" + instanceId + "?accepts_incomplete=" + acceptsIncomplete + "&plan_id=" + planId + "&service_id=" + serviceId + " status: " + status + ", result: " + result);

        return Response.status(status).entity(result).build(); // Return 410 with body of {} if previously deleted
    }

    @SuppressWarnings("static-method")
    @PATCH
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    @Path("v2/service_instances/{instanceId}")
    public Response update(@Context                          final HttpServletRequest httpServletRequest,
                           @PathParam("instanceId")          final String             instanceId,
                           @QueryParam("accepts_incomplete") final boolean            acceptsIncomplete,
                                                             final JSONObject         jsonObject)
           throws JSONException
    {
        LOGGER.info("PATCH /v2/service_instances/" + instanceId + "?accepts_incomplete=" + acceptsIncomplete + " request headers: " + headersString(httpServletRequest));

        validateAuthorization(httpServletRequest);

        final JSONObject originatingIdentity = getOriginatingIdentity(httpServletRequest);
        LOGGER.info("PATCH /v2/service_instances/" + instanceId + "?accepts_incomplete=" + acceptsIncomplete + " originating identity: " + originatingIdentity.toString());

        LOGGER.info("PATCH /v2/service_instances/" + instanceId + "?accepts_incomplete=" + acceptsIncomplete + " body: " + jsonObject);

        final JSONObject context        = getInputJSONObject(jsonObject, "context", true);
        final JSONObject parameters     = getInputJSONObject(jsonObject, "parameters", false); // Optional
        final String planId             = getInputString(jsonObject, "plan_id", true);
        final JSONObject previousValues = getInputJSONObject(jsonObject, "previous_values", true);
        final String previousPlanId     = getInputString(previousValues, "plan_id", true);
        final String serviceId          = getInputString(jsonObject, "service_id", true);

        final String platform = getInputString(context, "platform", true);

        // IBM Cloud context fields
        String accountId        = null;
        String crn              = null;
        String resourceGroupCRN = null;
        String targetCRN        = null;

        if ("ibmcloud".equals(platform))
        {
            // Retrieve the various IBM Cloud-specific context fields
            accountId        = getInputString(context, "account_id", true);
            crn              = getInputString(context, "crn", true);
            resourceGroupCRN = getInputString(context, "resource_group_crn", true);
            targetCRN        = getInputString(context, "target_crn", true);
        }

        final JSONObject result = new JSONObject();

        final int status;

        // If the service only supports asynchronous operations and acceptsIncomplete is not true
        if (ASYNC_SUPPORTED && ASYNC_REQUIRED && !acceptsIncomplete)
        {
            result.put("error",       "AsyncRequired");
            result.put("description", "This service plan requires client support for asynchronous service operations."); // TODO - This optional field is a user-facing message

            status = 422;
        }
        // TODO - Else if the service instance is requested as asynchronous (and time is needed to update beyond the standard timeout)
        else if (ASYNC_SUPPORTED && acceptsIncomplete)
        {
            // TODO - Kick off your asynchronous work here

            result.put("description", "This service instance is being updated asynchronously for you."); // TODO - This optional field is a user-facing message.
            result.put("operation",   "Test update"); // Passed in on subsequent fetch requests

            status = 202;
        }
        else
        {
            // TODO - Do your actual work here

            status = 200;
        }

        LOGGER.info("PATCH /v2/service_instances/" + instanceId + "?accepts_incomplete=" + acceptsIncomplete + " status: " + status + ", result: " + result);

        return Response.status(status).entity(result).build(); // Return 422 if this service instance does not support service plan update with result body including description field
    }

    @SuppressWarnings("static-method")
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("v2/service_instances/{instanceId}/last_operation")
    public Response fetch(@Context                  final HttpServletRequest httpServletRequest,
                          @PathParam("instanceId")  final String             instanceId,
                          @QueryParam("operation")  final String             operation,
                          @QueryParam("plan_id")    final String             planId,
                          @QueryParam("service_id") final String             serviceId)
           throws JSONException
    {
        LOGGER.info("GET /v2/service_instances/" + instanceId + "?operation=" + operation + "&plan_id=" + planId + "&service_id=" + serviceId + " request headers: " + headersString(httpServletRequest));

        validateAuthorization(httpServletRequest);

        // TODO - Do your actual work here

        final String state;
        final String description;

        // TODO - If the asynchronous operation for this instance failed (hardcoded in the sample as false)
        if (false)
        {
            state       = "failed";
            description = "This asynchronous operation failed due to <some reason>"; // TODO - Provide failure message
        }
        // TODO - Else if the asynchronous operation for this instance is complete (hardcoded in the sample as true)
        else if (true)
        {
            state       = "succeeded";
            description = "This asynchronous operation is complete"; // TODO - This optional field is a user-facing message
        }
        else
        {
            state       = "in progress";
            description = "This asynchronous operation is xx% complete"; // TODO - This optional field is a user-facing message
        }

        final JSONObject result = new JSONObject();

        result.put("state", state);
        result.put("description",  description);

        LOGGER.info("GET /v2/service_instances/" + instanceId + "?operation=" + operation + "&plan_id=" + planId + "&service_id=" + serviceId + " result: " + result);

        return Response.ok(result).build();
    }

    @SuppressWarnings("static-method")
    @GET
    @Path("dashboard/{instanceId}")
    public Response dashboard(@Context                 final HttpServletRequest httpServletRequest,
                              @PathParam("instanceId") final String             instanceId)
           throws JSONException,
                  UnsupportedEncodingException,
                  URISyntaxException
    {
        LOGGER.info("GET /dashboard/" + instanceId + " request headers: " + headersString(httpServletRequest));

        final URI uri = new URI(getIAMIdentityEndpoint("authorization_endpoint")         +
                                "?client_id=" + URLEncoder.encode(CLIENT_ID, "UTF-8")    +
                                "&redirect_uri=" + getSSORedirectURI(httpServletRequest) +
                                "&response_type=code"                                    +
                                "&state=" + URLEncoder.encode(instanceId, "UTF-8"));

        LOGGER.info("Dashboard GET redirect URI: " + uri);

        return Response.seeOther(uri).build();
    }

    @SuppressWarnings("static-method")
    @GET
    @Produces(MediaType.TEXT_HTML)
    @Path("sso_dashboard")
    public Response ssoDashboard(@Context             final HttpServletRequest httpServletRequest,
                                 @QueryParam("code")  final String             code,
                                 @QueryParam("state") final String             state)
           throws JSONException,
                  URISyntaxException,
                  UnsupportedEncodingException
    {
        LOGGER.info("GET /sso_dashboard?code=" + code + "&state=" + state + " request headers: " + headersString(httpServletRequest));

        final String accessToken = getAccessToken(getIAMIdentityEndpoint("token_endpoint"),
                                                  code,
                                                  getSSORedirectURI(httpServletRequest));

        if (accessToken != null)
        {
            final String apiKeyToken = getAPIKeyToken();

            if (apiKeyToken != null)
            {
                final boolean manage = getManageServiceInstance(accessToken,
                                                                apiKeyToken,
                                                                state);

                if (manage)
                {
                    // TODO - Add your actual administrative page here instead of the string below
                    return Response.ok("You can manage this service instance").build();
                }
            }
        }

        return createHTMLResponse(Status.UNAUTHORIZED,
                                  "You are not authorized to manage this service instance");
    }

    /**
     * IBM Cloud Enablement Extension: enable service instance
     */
    @SuppressWarnings("static-method")
    @PUT
    @Consumes(MediaType.APPLICATION_JSON)
    @Path("bluemix_v1/service_instances/{instanceId}")
    public Response enable(@Context                 final HttpServletRequest httpServletRequest,
                           @PathParam("instanceId") final String             instanceId,
                                                    final JSONObject         jsonObject)
           throws JSONException
    {
        LOGGER.info("PUT /bluemix_v1/service_instances/" + instanceId + " request headers: " + headersString(httpServletRequest));

        LOGGER.info("PUT /bluemix_v1/service_instances/" + instanceId + " body: " + jsonObject);

        validateAuthorization(httpServletRequest);

        final boolean enabled    = getInputBoolean(jsonObject, "enabled", true).booleanValue();
        final String initiatorId = getInputString(jsonObject, "initiator_id", true);
        final String reasonCode  = getInputString(jsonObject, "reason_code", true);

        // TODO - Do your actual work here

        return Response.noContent().build();
    }

    /**
     * IBM Cloud Enablement Extension: service instance state inquiry.
     */
    @SuppressWarnings("static-method")
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Path("bluemix_v1/service_instances/{instanceId}")
    public Response state(@Context                 final HttpServletRequest httpServletRequest,
                          @PathParam("instanceId") final String             instanceId)
           throws JSONException
    {
        LOGGER.info("GET /bluemix_v1/service_instances/" + instanceId + " request headers: " + headersString(httpServletRequest));

        validateAuthorization(httpServletRequest);

        // TODO - Do your actual work here

        final JSONObject result = new JSONObject();

        // true or false
        result.put("enabled", true);

        // true or false. Only meaningful if active is true. Defaults to true if not set.
        result.put("active",  true);

        // Last accessed/modified in milliseconds since the epoch. Only meaningful if enabled is true and active is false.
        // If enabled is true and active is false and this value is more than the number of days in the past identified by the PLM,
        // this is a reaping candidate. If enabled is true and active is false and this is not set, this is an immediate reaping candidate.
        result.put("last_active", System.currentTimeMillis());

        LOGGER.info("GET /bluemix_v1/service_instances/" + instanceId + " result: " + result);

        return Response.ok(result).build();
    }

    private static String headersString(final HttpServletRequest request)
    {
        final Map<String, List<String>> headerMap = new TreeMap<String, List<String>>();

        final Enumeration<String> headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements())
        {
            final List<String> headerValueList = new ArrayList<String>();

            final String headerName = headerNames.nextElement();

            final Enumeration<String> headerValues = request.getHeaders(headerName);
            while (headerValues.hasMoreElements())
            {
                headerValueList.add(headerValues.nextElement());
            }

            headerMap.put(headerName,
                          headerValueList);
        }

        return headerMap.toString();
    }

    private static void validateAuthorization(final HttpServletRequest request)
            throws JSONException
    {
        final String authorization = request.getHeader("authorization");

        if (authorization != null)
        {
            if (authorization.startsWith("Basic "))
            {
                final String basicAuthEncoded = authorization.substring(6);

                final byte[] basicAuthDecoded = DatatypeConverter.parseBase64Binary(basicAuthEncoded);

                final String[] split = new String(basicAuthDecoded).split(":");

                if (split.length == 2)
                {
                    if ((SERVICE_BROKER_USER.equals(split[0])) &&
                        (SERVICE_BROKER_PASSWORD.equals(split[1])))
                    {
                        return;
                    }
                }
            }
        }

        throw new WebApplicationException(createJSONResponse(Status.UNAUTHORIZED,
                                                             "WWW-Authenticate",
                                                             "Basic realm=\"Restricted Area\"",
                                                             "Not authorized"));
    }

    private static JSONObject getOriginatingIdentity(final HttpServletRequest request)
            throws JSONException
    {
        final JSONObject result = new JSONObject();

        final String originatingIdentity = request.getHeader("x-broker-api-originating-identity");

        if (originatingIdentity != null)
        {
            final String[] strings = originatingIdentity.split(" ");

            result.put("platform",  strings[0]);
            result.put("value", new JSONObject(new String(Base64.getDecoder().decode(strings[1]))));
        }

        return result;
    }

    @SuppressWarnings("unchecked")
    private static <T> T getInput(final JSONObject jsonObject,
                                  final String     name,
                                  final Class<T>   inputClass,
                                  final boolean    required)
            throws JSONException
    {
        final Object input = jsonObject.opt(name);

        if (input == null)
        {
            if (required)
            {
                throw new WebApplicationException(createJSONResponse(Status.BAD_REQUEST,
                                                                     name + " not found in JSON payload"));
            }

            return null;
        }

        if (!(inputClass.isInstance(input)))
        {
            throw new WebApplicationException(createJSONResponse(Status.BAD_REQUEST,
                                                                 name + " must be of type " + inputClass.getName()));
        }

        return (T) input;
    }

    private static Boolean getInputBoolean(final JSONObject jsonObject,
                                           final String     name,
                                           final boolean    required)
            throws JSONException
    {
        return getInput(jsonObject,
                        name,
                        Boolean.class,
                        required);
    }

    private static JSONObject getInputJSONObject(final JSONObject jsonObject,
                                                 final String     name,
                                                 final boolean    required)
            throws JSONException
    {
        return getInput(jsonObject,
                        name,
                        JSONObject.class,
                        required);
    }

    private static String getInputString(final JSONObject jsonObject,
                                         final String     name,
                                         final boolean    required)
            throws JSONException
    {
        final String string = getInput(jsonObject,
                                       name,
                                       String.class,
                                       required);

        if (string == null)
        {
            return null;
        }

        if (string.trim().isEmpty())
        {
            throw new WebApplicationException(createJSONResponse(Status.BAD_REQUEST,
                                                                 name + " cannot be empty"));
        }

        return string;
    }

    private static String getSSORedirectURI(final HttpServletRequest httpServletRequest)
            throws URISyntaxException
    {
        return new URI("https",
                       httpServletRequest.getServerName(),
                       httpServletRequest.getContextPath() + "/sso_dashboard",
                       null).toString();
    }

    private static Resource createResource(final String urlString,
                                           final String authorization)
    {
        final ClientConfig clientConfig = new ClientConfig();
        clientConfig.setBypassHostnameVerification(true);

        final RestClient restClient = new RestClient(clientConfig);

        Resource resource = restClient.resource(urlString).accept(MediaType.APPLICATION_JSON_TYPE);

        if (authorization != null)
        {
            resource = resource.header("Authorization",
                                       authorization);
        }

        return resource;
    }

    private static JSONObject handleClientResponse(final String         urlString,
                                                   final String         method,
                                                   final ClientResponse clientResponse)
            throws JSONException
    {
        final int statusCode = clientResponse.getStatusCode();

        final JSONObject jsonObject = clientResponse.getEntity(JSONObject.class);

        if (HttpServletResponse.SC_OK == statusCode)
        {
            LOGGER.info("Successful "        +
                        method               +
                        " response for url " +
                        urlString            +
                        ", JSON: "           +
                        String.valueOf(jsonObject));

            return jsonObject;
        }

        if ((HttpServletResponse.SC_BAD_REQUEST  == statusCode) ||
            (HttpServletResponse.SC_UNAUTHORIZED == statusCode) ||
            (HttpServletResponse.SC_FORBIDDEN    == statusCode) ||
            (HttpServletResponse.SC_NOT_FOUND    == statusCode))
        {
            LOGGER.warning(method +
                           " response for url " +
                           urlString            +
                           " is status: "       +
                           statusCode           +
                           ", JSON: "           +
                           String.valueOf(jsonObject));

            return null;
        }

        throw new WebApplicationException(createJSONResponse(Status.INTERNAL_SERVER_ERROR,
                                                             "Unable to "         +
                                                             method               +
                                                             " "                  +
                                                             urlString            +
                                                             ". Status code: "   +
                                                             statusCode           +
                                                             ". Response JSON: " +
                                                             String.valueOf(jsonObject)));
    }

    private static JSONObject doGet(final String urlString,
                                    final String authorization)
            throws JSONException
    {
        final Resource resource = createResource(urlString,
                                                 authorization);

        final ClientResponse clientResponse = resource.get();

        return handleClientResponse(urlString,
                                    "GET",
                                    clientResponse);
    }

    private static JSONObject doPost(final String    urlString,
                                     final String    authorization,
                                     final MediaType contentType,
                                     final String    content)
            throws JSONException
    {
        final Resource resource = createResource(urlString,
                                                 authorization);

        final ClientResponse clientResponse = resource.contentType(contentType).post(content);

        return handleClientResponse(urlString,
                                    "POST",
                                    clientResponse);
    }

    private static String getIAMIdentityEndpoint(final String endpoint)
            throws JSONException
    {
        final JSONObject jsonObject = doGet(IAM_IDENTITY_ENDPOINT,
                                            null);

        if (jsonObject == null)
        {
            throw new WebApplicationException(createJSONResponse(Status.INTERNAL_SERVER_ERROR,
                                                                 "Unable to access url " +
                                                                 IAM_IDENTITY_ENDPOINT   +
                                                                 "."));
        }

        return jsonObject.getString(endpoint);
    }

    private static String getAccessToken(final String tokenEndpoint,
                                         final String code,
                                         final String redirectURI)
            throws JSONException,
                   UnsupportedEncodingException
    {
        final String form = "client_id=" + URLEncoder.encode(CLIENT_ID, "UTF-8")       +
                            "&client_secret=" + CLIENT_SECRET                          +
                            "&code=" + URLEncoder.encode(code, "UTF-8")                +
                            "&grant_type=authorization_code"                           +
                            "&redirect_uri=" + URLEncoder.encode(redirectURI, "UTF-8") +
                            "&response_type=cloud_iam";

        final String token = CLIENT_ID + ":" + CLIENT_SECRET;

        final String authorization = "Basic " + DatatypeConverter.printBase64Binary(token.getBytes("UTF-8"));

        final JSONObject jsonObject = doPost(tokenEndpoint,
                                             authorization,
                                             MediaType.APPLICATION_FORM_URLENCODED_TYPE,
                                             form);

        if (jsonObject == null)
        {
            return null;
        }

        final String accessToken = jsonObject.getString("access_token");

        LOGGER.info("getAccessToken: " + accessToken);

        return accessToken;
    }

    private static String getAPIKeyToken()
            throws JSONException
    {
        final String urlString = IAM_ENDPOINT + "/identity/token";

        final String form = "apikey=" + API_KEY                                  +
                            "&grant_type=urn:ibm:params:oauth:grant-type:apikey" +
                            "&response_type=cloud_iam";

        final JSONObject jsonObject = doPost(urlString,
                                             null,
                                             MediaType.APPLICATION_FORM_URLENCODED_TYPE,
                                             form);

        if (jsonObject == null)
        {
            return null;
        }

        final String accessToken = jsonObject.getString("access_token");

        LOGGER.info("getAPIKeyToken: " + accessToken);

        return accessToken;
    }

    private static boolean getManageServiceInstance(final String accessToken,
                                                    final String apiKeyToken,
                                                    final String instanceId)
            throws JSONException
    {
        final String accessTokenBody = new String(Base64.getDecoder().decode(accessToken.split("\\.")[1]));
        LOGGER.info("getManageServiceInstance decoded access token body: " + accessTokenBody);

        final JSONObject accessTokenBodyJSONObject = new JSONObject(accessTokenBody);
        final String iamId = accessTokenBodyJSONObject.getString("iam_id");
        final String scope = accessTokenBodyJSONObject.getString("scope");

        final String urlString = IAM_ENDPOINT + "/v2/authz";

        final JSONObject attributesJSONObject = new JSONObject();
        attributesJSONObject.put("id", iamId);
        attributesJSONObject.put("scope", scope);

        final JSONObject subjectJSONObject = new JSONObject();
        subjectJSONObject.put("attributes", attributesJSONObject);

        final JSONObject resourceJSONObject = new JSONObject();
        resourceJSONObject.put("crn", instanceId);

        final JSONObject arrayEntryJSONObject = new JSONObject();
        arrayEntryJSONObject.put("subject", subjectJSONObject);
        arrayEntryJSONObject.put("resource", resourceJSONObject);
        arrayEntryJSONObject.put("action",  SERVICE_NAME + ".dashboard.view");

        final JSONArray content = new JSONArray();
        content.add(arrayEntryJSONObject);

        LOGGER.info("getManageServiceInstance content: " + content);

        final JSONObject resultJSONObject = doPost(urlString,
                                                   apiKeyToken,
                                                   MediaType.APPLICATION_JSON_TYPE,
                                                   content.toString(4));

        if (resultJSONObject == null)
        {
            return false;
        }

        final JSONArray responses = resultJSONObject.getJSONArray("responses");

        if (responses.length() == 0)
        {
            return false;
        }

        final Object arrayEntry = responses.getIndex(0);

        if (arrayEntry instanceof JSONObject)
        {
            final JSONObject resultArrayEntryJSONObject = (JSONObject) arrayEntry;
            final String status = resultArrayEntryJSONObject.getString("status");

            if (!"200".equals(status))
            {
                throw new WebApplicationException(createJSONResponse(Status.INTERNAL_SERVER_ERROR,
                                                                     "Unable to access url " +
                                                                     urlString               +
                                                                     "."));
            }

            final JSONObject authorizationDecision = resultArrayEntryJSONObject.getJSONObject("authorizationDecision");
            return authorizationDecision.getBoolean("permitted");
        }

        return false;
    }

    private static Response createHTMLResponse(final Status status,
                                               final String text)
    {
        LOGGER.severe("Response status: " + status.getStatusCode() + ", text: " + text);

        return Response.status(status).type(MediaType.TEXT_HTML).entity(text).build();
    }

    private static Response createJSONResponse(final Status status,
                                               final String text)
            throws JSONException
    {
        LOGGER.severe("Response status: " + status.getStatusCode() + ", text: " + text);

        final JSONObject jsonObject = new JSONObject();
        jsonObject.put("description", text);

        return Response.status(status).type(MediaType.APPLICATION_JSON).entity(jsonObject).build();
    }

    private static Response createJSONResponse(final Status status,
                                               final String header,
                                               final String headerValue,
                                               final String text)
            throws JSONException
    {
        final JSONObject jsonObject = new JSONObject();
        jsonObject.put("description", text);

        return Response.status(status).header(header, headerValue).type(MediaType.APPLICATION_JSON).entity(jsonObject).build();
    }

}